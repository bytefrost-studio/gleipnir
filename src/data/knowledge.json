{
  "microservicios": {
    "conceptos": [
      {
        "titulo": "Arquitectura de Microservicios",
        "texto": "Estilo arquitectónico que estructura una aplicación como una colección de servicios pequeños, autónomos y débilmente acoplados. Cada servicio es responsable de una única capacidad de negocio y puede ser desarrollado, desplegado y escalado de forma independiente. Principios clave: Single Responsibility, Autonomía, Descentralización de datos, Diseño para fallos, Automatización de infraestructura."
      },
      {
        "titulo": "API Gateway Pattern",
        "texto": "Punto de entrada único que actúa como reverse proxy. Responsabilidades: Request routing, API composition, Protocol translation, Rate limiting, Authentication/Authorization, Load balancing, Caching, Request/Response transformation. Implementaciones: Kong (open-source), AWS API Gateway, Netflix Zuul/Spring Cloud Gateway, Traefik, NGINX Plus. Anti-patterns: Gateway monolítico, lógica de negocio en gateway."
      },
      {
        "titulo": "Service Discovery",
        "texto": "Mecanismo para localizar servicios dinámicamente. Client-side discovery: cliente consulta registry y balancea (Netflix Eureka + Ribbon). Server-side discovery: load balancer consulta registry (AWS ELB + Route 53). Service Registry: Consul (health checking, KV store), etcd, ZooKeeper. Self-registration vs Third-party registration. DNS-based: Kubernetes CoreDNS, AWS Cloud Map."
      },
      {
        "titulo": "Circuit Breaker Pattern",
        "texto": "Patrón de resiliencia con tres estados: Closed (normal), Open (fallback), Half-Open (testing). Métricas: failure threshold, success threshold, timeout. Implementaciones: Resilience4j (Java), Polly (.NET), Hystrix (deprecated). Fallback strategies: cache, default value, alternative service. Combinado con: Retry pattern, Timeout pattern, Bulkhead pattern. Monitoring crucial para ajustar thresholds."
      },
      {
        "titulo": "Event-Driven Architecture",
        "texto": "Comunicación asíncrona mediante eventos. Patrones: Event Notification (notifica cambio), Event-Carried State Transfer (incluye datos), Event Sourcing (eventos como fuente de verdad). Message Brokers: Apache Kafka (log distribuido, particiones, consumer groups), RabbitMQ (AMQP, exchanges, queues), AWS SNS/SQS. Garantías: at-least-once, at-most-once, exactly-once. Idempotencia es crítica."
      },
      {
        "titulo": "Saga Pattern",
        "texto": "Gestión de transacciones distribuidas sin 2PC. Choreography: servicios escuchan eventos y reaccionan (descentralizado, complejo de debuggear). Orchestration: coordinador central maneja flujo (centralizado, más fácil de entender). Compensating transactions para rollback. Implementaciones: Temporal, Camunda, AWS Step Functions. Semantic lock, Commutative updates, Pessimistic view, Reread value, Version file, By value."
      },
      {
        "titulo": "CQRS (Command Query Responsibility Segregation)",
        "texto": "Separa modelo de lectura del de escritura. Commands: modifican estado, no retornan datos. Queries: leen datos, no modifican. Beneficios: optimización independiente, escalado diferenciado, modelos especializados. Eventual consistency entre modelos. Combinado con Event Sourcing: eventos rebuilden read model. Proyecciones: transforman eventos en vistas optimizadas. Complejidad adicional justificada en dominios complejos."
      },
      {
        "titulo": "Database per Service",
        "texto": "Cada microservicio posee su base de datos. Beneficios: loose coupling, libertad tecnológica (polyglot persistence), escalado independiente. Desafíos: consistencia eventual, queries distribuidas, transacciones distribuidas. Patrones: API Composition (agregar datos via APIs), CQRS (vistas desnormalizadas). Data sovereignty: servicio es dueño exclusivo. Shared database es anti-pattern pero a veces pragmático en migración."
      },
      {
        "titulo": "Service Mesh",
        "texto": "Capa de infraestructura dedicada para comunicación service-to-service. Data plane: proxies sidecar (Envoy) interceptan tráfico. Control plane: configura proxies (Istio, Linkerd, Consul Connect). Features: mTLS automático, traffic management, observability, circuit breaking, retries, load balancing, canary deployments. Reduce código de infraestructura en servicios. Overhead de latencia y recursos."
      },
      {
        "titulo": "Distributed Tracing",
        "texto": "Seguimiento de requests a través de múltiples servicios. Trace: viaje completo de request. Span: unidad de trabajo en un servicio. Context propagation: headers (traceparent, b3). Herramientas: Jaeger, Zipkin, AWS X-Ray, Datadog APM. OpenTelemetry: estándar unificado para traces, metrics, logs. Sampling strategies: head-based, tail-based. Correlación con logs y métricas. Esencial para debugging en sistemas distribuidos."
      },
      {
        "titulo": "Strangler Fig Pattern",
        "texto": "Migración incremental de monolito a microservicios. Fases: 1) Identificar bounded contexts, 2) Crear facade/proxy, 3) Extraer funcionalidad gradualmente, 4) Redirigir tráfico al nuevo servicio, 5) Eliminar código legacy. Anti-corruption layer: traduce entre modelos. Branch by abstraction: abstracciones permiten cambiar implementación. Reduce riesgo vs big bang rewrite. Métricas para validar comportamiento equivalente."
      },
      {
        "titulo": "Bulkhead Pattern",
        "texto": "Aislamiento de fallos inspirado en compartimentos de barcos. Tipos: Thread pool bulkhead (pool dedicado por dependencia), Semaphore bulkhead (límite de llamadas concurrentes). Previene que un servicio lento consuma todos los recursos. Configuración: max concurrent calls, max wait duration. Combinado con Circuit Breaker y Timeout. Implementaciones: Resilience4j, Hystrix. Sizing requiere análisis de carga y SLAs."
      },
      {
        "titulo": "Sidecar Pattern",
        "texto": "Componente auxiliar desplegado junto al servicio principal. Responsabilidades: logging, monitoring, configuration, networking, security. Beneficios: separación de concerns, reutilización, independencia de lenguaje. Service Mesh usa sidecars (Envoy). Ambassador pattern: proxy saliente. Adapter pattern: estandariza interfaces. Kubernetes: pod con múltiples containers compartiendo network namespace. Overhead de recursos por sidecar."
      },
      {
        "titulo": "API Versioning Strategies",
        "texto": "Estrategias: URI versioning (/v1/users), Query parameter (?version=1), Header versioning (Accept-Version), Content negotiation (Accept: application/vnd.api.v1+json). Semantic versioning para APIs: MAJOR.MINOR.PATCH. Breaking changes requieren nueva versión major. Deprecation policy: anunciar, período de gracia, sunset. Consumer-Driven Contract Testing: contratos definen expectativas. Backward compatibility cuando sea posible."
      },
      {
        "titulo": "Observability: Logs, Metrics, Traces",
        "texto": "Three pillars of observability. Logs: eventos discretos, structured logging (JSON), centralizados (ELK Stack, Loki). Metrics: mediciones numéricas agregables, tipos (counter, gauge, histogram, summary), Prometheus + Grafana. Traces: flujo de requests distribuidos. Correlation IDs unen los tres. SLIs (indicadores), SLOs (objetivos), SLAs (acuerdos). Alerting basado en SLOs. Runbooks para incidentes. Chaos engineering para validar."
      }
    ],
    "preguntas": [
      {
        "pregunta": "¿Cuál es la principal ventaja de la arquitectura de microservicios sobre monolitos?",
        "opciones": [
          "Menor complejidad operacional",
          "Despliegue y escalado independiente de servicios",
          "Menor latencia en comunicación",
          "Requiere menos infraestructura"
        ],
        "respuesta": 1
      },
      {
        "pregunta": "¿Qué patrón se utiliza para prevenir fallos en cascada entre microservicios?",
        "opciones": [
          "Singleton Pattern",
          "Factory Pattern",
          "Circuit Breaker Pattern",
          "Observer Pattern"
        ],
        "respuesta": 2
      },
      {
        "pregunta": "En el patrón Saga, ¿qué tipo usa un coordinador central para manejar el flujo?",
        "opciones": [
          "Choreography",
          "Orchestration",
          "Event Sourcing",
          "CQRS"
        ],
        "respuesta": 1
      },
      {
        "pregunta": "¿Qué patrón separa el modelo de lectura del modelo de escritura?",
        "opciones": [
          "Event Sourcing",
          "Saga Pattern",
          "CQRS",
          "Service Mesh"
        ],
        "respuesta": 2
      },
      {
        "pregunta": "¿Cuál es el principal desafío del patrón Database per Service?",
        "opciones": [
          "Mayor costo de licencias",
          "Consistencia eventual y queries distribuidas",
          "Menor rendimiento",
          "Dificultad de backup"
        ],
        "respuesta": 1
      },
      {
        "pregunta": "¿Qué componente del Service Mesh intercepta el tráfico entre servicios?",
        "opciones": [
          "Control plane",
          "API Gateway",
          "Sidecar proxy (Data plane)",
          "Service Registry"
        ],
        "respuesta": 2
      },
      {
        "pregunta": "¿Qué herramienta es estándar unificado para traces, metrics y logs?",
        "opciones": [
          "Prometheus",
          "Jaeger",
          "OpenTelemetry",
          "Grafana"
        ],
        "respuesta": 2
      },
      {
        "pregunta": "El patrón Strangler Fig se utiliza para:",
        "opciones": [
          "Escalar microservicios horizontalmente",
          "Migrar incrementalmente de monolito a microservicios",
          "Implementar circuit breakers",
          "Gestionar transacciones distribuidas"
        ],
        "respuesta": 1
      },
      {
        "pregunta": "¿Qué patrón aísla recursos para prevenir que un servicio lento afecte a otros?",
        "opciones": [
          "Circuit Breaker",
          "Bulkhead",
          "Retry",
          "Timeout"
        ],
        "respuesta": 1
      },
      {
        "pregunta": "En Event-Driven Architecture, ¿qué garantía requiere idempotencia obligatoria?",
        "opciones": [
          "At-most-once",
          "Exactly-once",
          "At-least-once",
          "Best-effort"
        ],
        "respuesta": 2
      },
      {
        "pregunta": "¿Qué tipo de Service Discovery hace que el cliente consulte el registry directamente?",
        "opciones": [
          "Server-side discovery",
          "DNS-based discovery",
          "Client-side discovery",
          "Proxy-based discovery"
        ],
        "respuesta": 2
      },
      {
        "pregunta": "¿Cuáles son los tres pilares de la observabilidad?",
        "opciones": [
          "Security, Performance, Availability",
          "Logs, Metrics, Traces",
          "CI, CD, Monitoring",
          "Testing, Deployment, Monitoring"
        ],
        "respuesta": 1
      }
    ]
  },
  "aws": {
    "conceptos": [
      {
        "titulo": "EC2 (Elastic Compute Cloud)",
        "texto": "Servicio de cómputo escalable que proporciona capacidad de procesamiento en la nube. Permite lanzar instancias virtuales con diferentes tipos de hardware."
      },
      {
        "titulo": "S3 (Simple Storage Service)",
        "texto": "Servicio de almacenamiento de objetos altamente escalable y duradero. Ofrece 99.999999999% de durabilidad. Clases: Standard, Intelligent-Tiering, Glacier."
      },
      {
        "titulo": "Lambda",
        "texto": "Servicio serverless que ejecuta código en respuesta a eventos sin necesidad de provisionar servidores. Se cobra por tiempo de ejecución y memoria utilizada."
      },
      {
        "titulo": "DynamoDB",
        "texto": "Base de datos NoSQL completamente administrada, de alto rendimiento. Ofrece latencia de milisegundos de un solo dígito. Soporta modelos clave-valor y documentos."
      },
      {
        "titulo": "EKS (Elastic Kubernetes Service)",
        "texto": "Servicio administrado que facilita la ejecución de Kubernetes en AWS. Elimina la necesidad de instalar y operar el plano de control de Kubernetes."
      }
    ],
    "preguntas": [
      {
        "pregunta": "¿Qué servicio AWS es ideal para ejecutar código sin gestionar servidores?",
        "opciones": [
          "EC2",
          "Lambda",
          "ECS",
          "Lightsail"
        ],
        "respuesta": 1
      },
      {
        "pregunta": "¿Cuál es la durabilidad de Amazon S3?",
        "opciones": [
          "99.9%",
          "99.99%",
          "99.999999999%",
          "100%"
        ],
        "respuesta": 2
      },
      {
        "pregunta": "¿Qué tipo de base de datos es DynamoDB?",
        "opciones": [
          "Relacional",
          "Grafos",
          "NoSQL",
          "Time-series"
        ],
        "respuesta": 2
      },
      {
        "pregunta": "¿Qué servicio AWS administra Kubernetes?",
        "opciones": [
          "ECS",
          "Fargate",
          "EKS",
          "Beanstalk"
        ],
        "respuesta": 2
      }
    ]
  },
  "typescript": {
    "conceptos": [
      {
        "titulo": "Tipos Estáticos",
        "texto": "TypeScript añade tipado estático opcional a JavaScript. Permite detectar errores en tiempo de compilación. Tipos básicos: string, number, boolean, array, tuple, enum, any, void."
      },
      {
        "titulo": "Interfaces",
        "texto": "Definen la estructura de un objeto, especificando qué propiedades y métodos debe tener. Son extensibles y pueden ser implementadas por clases."
      },
      {
        "titulo": "Generics",
        "texto": "Permiten crear componentes reutilizables que trabajan con múltiples tipos. Proporcionan type safety sin sacrificar flexibilidad."
      },
      {
        "titulo": "Type Guards",
        "texto": "Técnicas para narrowing de tipos en runtime. Incluyen: typeof, instanceof, in operator. Permiten que TypeScript infiera tipos más específicos."
      },
      {
        "titulo": "Decorators",
        "texto": "Metaprogramación que permite añadir anotaciones y modificar clases. Usados extensivamente en NestJS y Angular."
      }
    ],
    "preguntas": [
      {
        "pregunta": "¿Cuál es la principal ventaja de TypeScript sobre JavaScript?",
        "opciones": [
          "Es más rápido en runtime",
          "Tipado estático y detección de errores en compilación",
          "Usa menos memoria",
          "No requiere transpilación"
        ],
        "respuesta": 1
      },
      {
        "pregunta": "¿Qué permite crear componentes reutilizables con múltiples tipos?",
        "opciones": [
          "Interfaces",
          "Enums",
          "Generics",
          "Tuples"
        ],
        "respuesta": 2
      },
      {
        "pregunta": "¿Qué son los Type Guards en TypeScript?",
        "opciones": [
          "Funciones de seguridad",
          "Técnicas para narrowing de tipos en runtime",
          "Validadores de esquemas",
          "Protectores de memoria"
        ],
        "respuesta": 1
      },
      {
        "pregunta": "¿En qué frameworks se usan extensivamente los Decorators?",
        "opciones": [
          "React y Vue",
          "Express y Koa",
          "NestJS y Angular",
          "Next.js y Nuxt"
        ],
        "respuesta": 2
      }
    ]
  },
  "kubernetes": {
    "conceptos": [
      {
        "titulo": "Pod",
        "texto": "Unidad mas pequena desplegable en Kubernetes. Contenedores compartiendo almacenamiento y red."
      },
      {
        "titulo": "Deployment",
        "texto": "Gestiona estado deseado de Pods. Rolling updates y rollback. Define replicas."
      },
      {
        "titulo": "Service",
        "texto": "Conjunto logico de Pods. ClusterIP (interno), NodePort (nodos), LoadBalancer (externo)."
      },
      {
        "titulo": "ConfigMap y Secrets",
        "texto": "ConfigMap guarda config no confidencial. Secrets almacena passwords cifrados."
      },
      {
        "titulo": "Ingress",
        "texto": "Acceso externo HTTP/HTTPS. Balanceo, SSL, virtual hosting. Requiere Ingress Controller."
      },
      {
        "titulo": "Namespaces",
        "texto": "Aislan recursos en cluster. Separan ambientes dev/staging/prod."
      },
      {
        "titulo": "HPA",
        "texto": "Horizontal Pod Autoscaler. Escala Pods segun CPU/memoria automaticamente."
      }
    ],
    "preguntas": [
      {
        "pregunta": "Unidad mas pequena desplegable en K8s?",
        "opciones": [
          "Container",
          "Pod",
          "Deployment",
          "Service"
        ],
        "respuesta": 1
      },
      {
        "pregunta": "Objeto que permite rolling updates?",
        "opciones": [
          "Pod",
          "Service",
          "Deployment",
          "ConfigMap"
        ],
        "respuesta": 2
      },
      {
        "pregunta": "Service que expone puerto en cada nodo?",
        "opciones": [
          "ClusterIP",
          "NodePort",
          "LoadBalancer",
          "ExternalName"
        ],
        "respuesta": 1
      },
      {
        "pregunta": "Donde se guarda info sensible?",
        "opciones": [
          "ConfigMap",
          "Secrets",
          "Pod",
          "Volume"
        ],
        "respuesta": 1
      },
      {
        "pregunta": "Componente que escala Pods?",
        "opciones": [
          "Deployment",
          "Service",
          "HPA",
          "Ingress"
        ],
        "respuesta": 2
      },
      {
        "pregunta": "Para que sirven Namespaces?",
        "opciones": [
          "Almacenar datos",
          "Aislar recursos",
          "Gestionar redes",
          "Compilar"
        ],
        "respuesta": 1
      }
    ]
  },
  "nestjs": {
    "conceptos": [
      {
        "titulo": "Modulos",
        "texto": "Bloques que organizan codigo. Encapsulan providers, controllers, imports."
      },
      {
        "titulo": "Controllers",
        "texto": "Manejan HTTP requests. Decoradores @Get(), @Post(), @Delete() definen rutas."
      },
      {
        "titulo": "Providers",
        "texto": "Services son providers. @Injectable() marca clase. Inyeccion de dependencias."
      },
      {
        "titulo": "Pipes",
        "texto": "Transforman y validan datos. ValidationPipe valida DTOs automaticamente."
      },
      {
        "titulo": "Guards",
        "texto": "Auth y autorizacion. Implementan CanActivate. Deciden si procesar request."
      },
      {
        "titulo": "Interceptors",
        "texto": "Transforman resultados. Logging, caching, modificar respuestas."
      },
      {
        "titulo": "Middleware",
        "texto": "Se ejecuta antes del handler. Acceso a req/res. Logging, validacion headers."
      }
    ],
    "preguntas": [
      {
        "pregunta": "Decorador que marca clase inyectable?",
        "opciones": [
          "@Module()",
          "@Controller()",
          "@Injectable()",
          "@Service()"
        ],
        "respuesta": 2
      },
      {
        "pregunta": "Componente que maneja HTTP requests?",
        "opciones": [
          "Module",
          "Provider",
          "Controller",
          "Pipe"
        ],
        "respuesta": 2
      },
      {
        "pregunta": "Para que sirven Pipes?",
        "opciones": [
          "Auth",
          "Logging",
          "Validacion de datos",
          "Errores"
        ],
        "respuesta": 2
      },
      {
        "pregunta": "Interface que implementan Guards?",
        "opciones": [
          "CanHandle",
          "CanActivate",
          "CanAuth",
          "CanValidate"
        ],
        "respuesta": 1
      },
      {
        "pregunta": "Proposito de Interceptors?",
        "opciones": [
          "Rutas",
          "Transformar resultados",
          "Modulos",
          "DB"
        ],
        "respuesta": 1
      },
      {
        "pregunta": "Que se ejecuta primero en request?",
        "opciones": [
          "Guard",
          "Interceptor",
          "Middleware",
          "Pipe"
        ],
        "respuesta": 2
      }
    ]
  },
  "solid": {
    "conceptos": [
      {
        "titulo": "Single Responsibility (SRP)",
        "texto": "Clase con una unica razon para cambiar. Una sola responsabilidad."
      },
      {
        "titulo": "Open/Closed (OCP)",
        "texto": "Abierto para extension, cerrado para modificacion. Usar abstracciones."
      },
      {
        "titulo": "Liskov Substitution (LSP)",
        "texto": "Subclases sustituyen clase base sin alterar comportamiento."
      },
      {
        "titulo": "Interface Segregation (ISP)",
        "texto": "No depender de interfaces no usadas. Interfaces especificas mejor que generales."
      },
      {
        "titulo": "Dependency Inversion (DIP)",
        "texto": "Depender de abstracciones, no implementaciones concretas."
      }
    ],
    "preguntas": [
      {
        "pregunta": "Principio de una unica razon para cambiar?",
        "opciones": [
          "OCP",
          "SRP",
          "DIP",
          "ISP"
        ],
        "respuesta": 1
      },
      {
        "pregunta": "Principio de extender sin modificar?",
        "opciones": [
          "SRP",
          "OCP",
          "LSP",
          "ISP"
        ],
        "respuesta": 1
      },
      {
        "pregunta": "Principio de sustitucion de subclases?",
        "opciones": [
          "SRP",
          "ISP",
          "LSP",
          "DIP"
        ],
        "respuesta": 2
      },
      {
        "pregunta": "Principio de depender de abstracciones?",
        "opciones": [
          "SRP",
          "OCP",
          "LSP",
          "DIP"
        ],
        "respuesta": 3
      },
      {
        "pregunta": "Principio de no depender de interfaces no usadas?",
        "opciones": [
          "SRP",
          "OCP",
          "ISP",
          "DIP"
        ],
        "respuesta": 2
      }
    ]
  },
  "graphql": {
    "conceptos": [
      {
        "titulo": "Schema y Types",
        "texto": "Schema tipado. Tipos: Int, Float, String, Boolean, ID. Contrato cliente-servidor."
      },
      {
        "titulo": "Queries",
        "texto": "Operaciones de lectura. Cliente pide campos exactos. Evita over/under-fetching."
      },
      {
        "titulo": "Mutations",
        "texto": "Modifican datos: crear, actualizar, eliminar. Devuelven datos modificados."
      },
      {
        "titulo": "Resolvers",
        "texto": "Funciones que resuelven valores. Params: parent, args, context, info."
      },
      {
        "titulo": "Subscriptions",
        "texto": "Tiempo real via WebSockets. Notificaciones, chat, updates live."
      },
      {
        "titulo": "Fragments",
        "texto": "Campos reutilizables en queries. Evitan repeticion. Mejoran mantenibilidad."
      }
    ],
    "preguntas": [
      {
        "pregunta": "Problema de REST que GraphQL soluciona?",
        "opciones": [
          "Auth",
          "Over/under-fetching",
          "Caching",
          "Versionado"
        ],
        "respuesta": 1
      },
      {
        "pregunta": "Operacion que modifica datos?",
        "opciones": [
          "Query",
          "Mutation",
          "Subscription",
          "Resolver"
        ],
        "respuesta": 1
      },
      {
        "pregunta": "Que resuelve valores de campos?",
        "opciones": [
          "Schema",
          "Type",
          "Resolver",
          "Query"
        ],
        "respuesta": 2
      },
      {
        "pregunta": "Operacion de tiempo real?",
        "opciones": [
          "Query",
          "Mutation",
          "Subscription",
          "Resolver"
        ],
        "respuesta": 2
      },
      {
        "pregunta": "Que son Fragments?",
        "opciones": [
          "Tipos",
          "Campos reutilizables",
          "Auth",
          "Errores"
        ],
        "respuesta": 1
      }
    ]
  },
  "cicd": {
    "conceptos": [
      {
        "titulo": "Continuous Integration",
        "texto": "Integrar cambios frecuentemente. Build y tests automatizados. Detectar errores rapido."
      },
      {
        "titulo": "Continuous Delivery",
        "texto": "Codigo siempre desplegable. Automatiza release. Aprobacion manual para prod."
      },
      {
        "titulo": "Continuous Deployment",
        "texto": "Automatizacion completa hasta produccion. Todo cambio que pasa tests se despliega."
      },
      {
        "titulo": "Pipeline",
        "texto": "Pasos automatizados: build, test, analyze, deploy. Jenkins, GitHub Actions, GitLab CI."
      },
      {
        "titulo": "Infrastructure as Code",
        "texto": "Infra via archivos config. Terraform, CloudFormation. Versionado y reproducible."
      },
      {
        "titulo": "Blue-Green Deployment",
        "texto": "Dos ambientes identicos. Redirige trafico. Rollback instantaneo."
      }
    ],
    "preguntas": [
      {
        "pregunta": "Objetivo de Continuous Integration?",
        "opciones": [
          "Deploy a prod",
          "Integrar y detectar errores",
          "Gestionar infra",
          "Monitorear"
        ],
        "respuesta": 1
      },
      {
        "pregunta": "Diferencia entre Delivery y Deployment?",
        "opciones": [
          "No tests",
          "Deployment automatico hasta prod",
          "Delivery mas rapido",
          "Sin diferencia"
        ],
        "respuesta": 1
      },
      {
        "pregunta": "Herramienta NO de CI/CD?",
        "opciones": [
          "Jenkins",
          "GitHub Actions",
          "Terraform",
          "GitLab CI"
        ],
        "respuesta": 2
      },
      {
        "pregunta": "Estrategia con rollback instantaneo?",
        "opciones": [
          "Rolling",
          "Blue-Green",
          "Canary",
          "Recreate"
        ],
        "respuesta": 1
      },
      {
        "pregunta": "Que es IaC?",
        "opciones": [
          "Codigo cloud",
          "Infra via config files",
          "APIs",
          "Testing"
        ],
        "respuesta": 1
      }
    ]
  },
  "cleancode": {
    "conceptos": [
      {
        "titulo": "Nombres Significativos",
        "texto": "Revelan intencion. Evitar abreviaciones. Codigo auto-documentado."
      },
      {
        "titulo": "Funciones Pequenas",
        "texto": "Una sola cosa. Menos de 20 lineas ideal. Dividir si necesita comentarios."
      },
      {
        "titulo": "DRY (Do Not Repeat)",
        "texto": "Evitar duplicacion de codigo. Una representacion unica de conocimiento."
      },
      {
        "titulo": "KISS",
        "texto": "Keep It Simple. Evitar complejidad innecesaria. Lo simple funciona mejor."
      },
      {
        "titulo": "Comentarios Utiles",
        "texto": "Comentar el por que, no el que. Evitar comentarios obvios o desactualizados."
      },
      {
        "titulo": "Manejo de Errores",
        "texto": "Excepciones, no codigos de error. Contexto en mensajes. No ignorar excepciones."
      }
    ],
    "preguntas": [
      {
        "pregunta": "Que deben revelar nombres de variables?",
        "opciones": [
          "Tipo",
          "Intencion",
          "Autor",
          "Fecha"
        ],
        "respuesta": 1
      },
      {
        "pregunta": "Longitud ideal de funcion?",
        "opciones": [
          "100+ lineas",
          "50-100",
          "Menos de 20",
          "No importa"
        ],
        "respuesta": 2
      },
      {
        "pregunta": "Que significa DRY?",
        "opciones": [
          "Dev Rapido",
          "No Repetir Codigo",
          "Disenar Respuestas",
          "Documentar"
        ],
        "respuesta": 1
      },
      {
        "pregunta": "Comentarios a evitar?",
        "opciones": [
          "APIs",
          "Obvios/desactualizados",
          "Arquitectura",
          "Todos"
        ],
        "respuesta": 1
      },
      {
        "pregunta": "Mejor solucion segun KISS?",
        "opciones": [
          "Compleja",
          "Rapida",
          "Simple que funciona",
          "Con patrones"
        ],
        "respuesta": 2
      }
    ]
  },
  "serverless": {
    "conceptos": [
      {
        "titulo": "Arquitectura Serverless",
        "texto": "Modelo de ejecución donde el proveedor cloud gestiona la infraestructura dinámicamente. Características: sin gestión de servidores, escalado automático, pago por uso (pay-per-execution), stateless por diseño. FaaS (Function as a Service) es el componente principal. BaaS (Backend as a Service) complementa con servicios administrados. Beneficios: reducción de costos operativos, time-to-market rápido, escalabilidad inherente. Trade-offs: cold starts, vendor lock-in, límites de ejecución, debugging complejo."
      },
      {
        "titulo": "AWS Lambda: Fundamentos",
        "texto": "Servicio FaaS de AWS. Handler function: punto de entrada (event, context). Runtimes soportados: Node.js, Python, Java, Go, .NET, Ruby, Custom Runtime (provided.al2). Límites: 15 min timeout, 10GB memoria, 6MB payload síncrono, 256KB asíncrono. Modelo de facturación: GB-segundo (memoria × tiempo). Free tier: 1M requests/mes, 400,000 GB-segundos. Execution role (IAM) define permisos. Versiones y aliases para deployment management."
      },
      {
        "titulo": "Cold Starts y Optimización",
        "texto": "Cold start: inicialización cuando no hay instancias warm. Fases: descarga código, inicializa runtime, ejecuta código fuera del handler. Factores: tamaño del deployment package, runtime (Java/C# más lentos), VPC (añade ENI attachment ~10s). Mitigación: Provisioned Concurrency (instancias pre-calentadas, costo adicional), minimizar dependencias, lazy loading, mantener funciones warm con CloudWatch Events. Init phase optimization: mover código reutilizable fuera del handler. SnapStart (Java): reduce cold starts a ~200ms."
      },
      {
        "titulo": "Lambda Layers",
        "texto": "Paquetes de código compartido entre funciones. Usos: bibliotecas comunes, custom runtimes, dependencias pesadas. Límites: máximo 5 layers por función, 250MB unzipped total. Beneficios: reducir tamaño de deployment, compartir código entre funciones, versionado independiente. Layer se monta en /opt. Structure: /opt/nodejs/node_modules (Node), /opt/python (Python). Public layers: AWS-provided (SDK, Parameters and Secrets Extension). Custom layers via S3 o consola. ARN específico por versión."
      },
      {
        "titulo": "Invocation Models",
        "texto": "Synchronous: cliente espera respuesta (API Gateway, SDK invoke). Timeout máximo del cliente. Asynchronous: Lambda queue interno, hasta 2 retries automáticos (configurable). Dead Letter Queue (SQS/SNS) para fallos. Destinations: enrutar éxitos/fallos a otros servicios. Event source mapping: Lambda poll de streams (Kinesis, DynamoDB Streams, SQS). Batch processing, bisect on error, parallelization factor. Reserved concurrency: garantiza capacidad, puede throttlear. Error handling diferente por modelo."
      },
      {
        "titulo": "API Gateway: REST vs HTTP APIs",
        "texto": "REST API: features completos (caching, request validation, WAF integration, usage plans, API keys, private APIs). Mayor costo. HTTP API: 70% más barato, menor latencia, OIDC/OAuth2 nativo, auto-deploy. Menos features. WebSocket API: conexiones persistentes bidireccionales. Stages: dev/staging/prod. Integration types: Lambda proxy (event completo), Lambda custom (transformación), HTTP proxy, Mock, AWS service. Request/Response mapping templates (VTL). Throttling: account-level y per-method. Caching reduce latencia y costos."
      },
      {
        "titulo": "AWS Step Functions",
        "texto": "Orquestador visual de workflows serverless. State machine usando Amazon States Language (JSON). Task states: invocan Lambda, ECS, actividades. Choice state: branching condicional. Parallel state: ejecución concurrente. Map state: iteración dinámica sobre arrays. Wait state: delays. Error handling: Retry (exponential backoff), Catch (fallback). Standard Workflows: larga duración (hasta 1 año), exactly-once. Express Workflows: alta frecuencia, corta duración (5 min), at-least-once. Integración nativa con 220+ servicios AWS. Visual debugging en consola. Ideal para Saga pattern."
      },
      {
        "titulo": "Amazon EventBridge",
        "texto": "Event bus serverless para arquitecturas event-driven. Default bus: eventos AWS. Custom bus: eventos propios. Partner bus: SaaS integrations (Datadog, PagerDuty). Event pattern matching: filtros en JSON. Reglas: enrutan eventos a targets (Lambda, SQS, Step Functions, API destinations). Schema Registry: descubre y versiona schemas automáticamente. Archive y Replay: almacena eventos para replay histórico. Event transformation: Input Transformer modifica payload. Scheduler: cron y rate expressions. Content-based filtering reduce invocaciones innecesarias. Retry policy y DLQ por target."
      },
      {
        "titulo": "SQS y SNS en Serverless",
        "texto": "SQS (Simple Queue Service): colas de mensajes. Standard: alto throughput, at-least-once, posible desorden. FIFO: orden garantizado, exactly-once, 300 TPS (3000 con batching). Lambda polling: batch size configurable, long polling. Visibility timeout: evita procesamiento duplicado. DLQ: mensajes fallidos después de maxReceiveCount. SNS (Simple Notification Service): pub/sub. Topics: múltiples suscriptores (Lambda, SQS, HTTP, email, SMS). Fan-out pattern: SNS → múltiples SQS. Message filtering: suscriptores reciben solo mensajes relevantes. Combinación SQS+SNS para decoupling y buffer."
      },
      {
        "titulo": "DynamoDB para Serverless",
        "texto": "Base de datos NoSQL optimizada para serverless. On-demand capacity: auto-scaling inmediato, pago por request. Provisioned: capacidad predefinida, auto-scaling configurable. Single-digit millisecond latency. Partition key y optional sort key. Secondary indexes: GSI (global), LSI (local). Streams: captura cambios (INSERT, MODIFY, REMOVE), trigger Lambda. TTL: expiración automática de items. Transactions: ACID para múltiples items. DAX: caching in-memory (microsegundos). PartiQL: SQL-like queries. Global Tables: multi-region replication. Point-in-time recovery. Design patterns: single-table design, adjacency list."
      },
      {
        "titulo": "Lambda@Edge y CloudFront Functions",
        "texto": "Ejecutar código en edge locations de CloudFront. Lambda@Edge: Node.js/Python, 4 triggers (viewer request/response, origin request/response). Límites: 5s viewer, 30s origin, 128MB viewer, 10GB origin. Usos: A/B testing, authentication, URL rewrites, header manipulation. CloudFront Functions: JavaScript puro, solo viewer triggers, 1ms máximo, 2MB. Mayor escala, menor costo. Usos: cache key normalization, URL redirects, header validation. Deployment: replica automáticamente a todos los edge locations. Latencia ultra-baja para personalización."
      },
      {
        "titulo": "Seguridad en Serverless",
        "texto": "IAM Execution Role: principio de least privilege, policy específica por función. Resource-based policies: quién puede invocar la función. VPC integration: acceso a recursos privados (RDS, ElastiCache). NAT Gateway necesario para internet. Environment variables: configuración, KMS encryption at rest. Secrets Manager/Parameter Store: credenciales rotables, caching con Lambda extension. Input validation: sanitizar eventos, evitar injection. OWASP Serverless Top 10: injection, broken authentication, sensitive data exposure. WAF con API Gateway. Dependency scanning: npm audit, Snyk. Lambda Inspector para vulnerabilidades."
      },
      {
        "titulo": "Observabilidad en Serverless",
        "texto": "CloudWatch Logs: logs automáticos de Lambda, Log Insights para queries. CloudWatch Metrics: invocations, duration, errors, throttles, concurrent executions. Custom metrics con EMF (Embedded Metric Format). X-Ray: distributed tracing, service map, trace analysis. Active tracing habilitado en Lambda. Segments y subsegments. Lambda Insights: métricas de sistema (CPU, memory, network). CloudWatch Alarms: alertas en métricas. Dashboard consolidado. Third-party: Datadog, Lumigo, Thundra. Structured logging (JSON) facilita análisis. Correlation IDs para tracing end-to-end. Cost monitoring con Cost Explorer tags."
      },
      {
        "titulo": "Infrastructure as Code para Serverless",
        "texto": "AWS SAM (Serverless Application Model): extensión de CloudFormation optimizada para serverless. sam init, sam build, sam deploy. Template simplificado: AWS::Serverless::Function. Local testing: sam local invoke, sam local start-api. Serverless Framework: multi-cloud, plugins ecosystem, serverless.yml. CDK (Cloud Development Kit): infraestructura en código real (TypeScript, Python). L2/L3 constructs para patterns comunes. Terraform: provider AWS, modules reutilizables. CI/CD: CodePipeline, GitHub Actions. Blue/green deployments con CodeDeploy integrado en SAM. Traffic shifting gradual (canary, linear). Rollback automático en errores."
      },
      {
        "titulo": "Patrones Arquitectónicos Serverless",
        "texto": "API Backend: API Gateway + Lambda + DynamoDB. Event Processing: EventBridge/SNS → Lambda → DynamoDB/S3. Stream Processing: Kinesis/DynamoDB Streams → Lambda. Scheduled Tasks: EventBridge Scheduler → Lambda. Fan-out: SNS → múltiples Lambda/SQS. Saga Pattern: Step Functions orquestando Lambda. CQRS: writes a DynamoDB, reads desde DAX o replicas. Strangler Pattern: API Gateway enrutando a Lambda o legacy. Data Lake: S3 + Lambda triggers + Glue + Athena. GraphQL: AppSync con resolvers Lambda/DynamoDB. Real-time: WebSocket API + Lambda + DynamoDB. Cost optimization: right-sizing memory, batching, caching."
      }
    ],
    "preguntas": [
      {
        "pregunta": "¿Cuál es el tiempo máximo de ejecución de una función Lambda?",
        "opciones": [
          "5 minutos",
          "10 minutos",
          "15 minutos",
          "30 minutos"
        ],
        "respuesta": 2
      },
      {
        "pregunta": "¿Qué característica de Lambda mitiga los cold starts manteniendo instancias pre-calentadas?",
        "opciones": [
          "Reserved Concurrency",
          "Provisioned Concurrency",
          "Lambda Layers",
          "Lambda@Edge"
        ],
        "respuesta": 1
      },
      {
        "pregunta": "¿Cuál es el límite máximo de layers que se pueden adjuntar a una función Lambda?",
        "opciones": [
          "3 layers",
          "5 layers",
          "10 layers",
          "Sin límite"
        ],
        "respuesta": 1
      },
      {
        "pregunta": "¿Qué tipo de API Gateway es 70% más barato y tiene menor latencia?",
        "opciones": [
          "REST API",
          "HTTP API",
          "WebSocket API",
          "Private API"
        ],
        "respuesta": 1
      },
      {
        "pregunta": "¿Qué servicio de AWS es ideal para orquestar workflows serverless con manejo visual de estados?",
        "opciones": [
          "EventBridge",
          "Step Functions",
          "SQS",
          "Lambda Layers"
        ],
        "respuesta": 1
      },
      {
        "pregunta": "¿Qué tipo de Step Functions Workflow soporta duración de hasta 1 año?",
        "opciones": [
          "Express Workflows",
          "Standard Workflows",
          "Parallel Workflows",
          "Nested Workflows"
        ],
        "respuesta": 1
      },
      {
        "pregunta": "¿Qué patrón arquitectónico usa SNS para enviar un mensaje a múltiples colas SQS simultáneamente?",
        "opciones": [
          "Pub/Sub",
          "Fan-out",
          "Event Sourcing",
          "CQRS"
        ],
        "respuesta": 1
      },
      {
        "pregunta": "¿Qué feature de DynamoDB captura cambios en la tabla para triggear Lambda?",
        "opciones": [
          "DynamoDB DAX",
          "DynamoDB Streams",
          "DynamoDB TTL",
          "DynamoDB Transactions"
        ],
        "respuesta": 1
      },
      {
        "pregunta": "¿Cuál es el tiempo máximo de ejecución para CloudFront Functions?",
        "opciones": [
          "1 milisegundo",
          "5 segundos",
          "30 segundos",
          "15 minutos"
        ],
        "respuesta": 0
      },
      {
        "pregunta": "¿Qué servicio de AWS se recomienda para almacenar credenciales rotables en aplicaciones serverless?",
        "opciones": [
          "Environment Variables",
          "S3 Buckets",
          "Secrets Manager",
          "Lambda Layers"
        ],
        "respuesta": 2
      },
      {
        "pregunta": "¿Qué herramienta proporciona distributed tracing nativo en AWS serverless?",
        "opciones": [
          "CloudWatch Logs",
          "CloudWatch Metrics",
          "X-Ray",
          "CloudTrail"
        ],
        "respuesta": 2
      },
      {
        "pregunta": "¿Qué framework de IaC es una extensión de CloudFormation optimizada para serverless?",
        "opciones": [
          "Terraform",
          "CDK",
          "AWS SAM",
          "Serverless Framework"
        ],
        "respuesta": 2
      },
      {
        "pregunta": "En el modelo de invocación asíncrono de Lambda, ¿cuántos reintentos automáticos se realizan por defecto?",
        "opciones": [
          "0 reintentos",
          "1 reintento",
          "2 reintentos",
          "3 reintentos"
        ],
        "respuesta": 2
      },
      {
        "pregunta": "¿Qué tipo de cola SQS garantiza orden exacto y exactly-once processing?",
        "opciones": [
          "Standard Queue",
          "FIFO Queue",
          "Priority Queue",
          "Delay Queue"
        ],
        "respuesta": 1
      },
      {
        "pregunta": "¿Qué capacidad de DynamoDB se recomienda para cargas de trabajo impredecibles en serverless?",
        "opciones": [
          "Provisioned Capacity",
          "On-demand Capacity",
          "Reserved Capacity",
          "Burst Capacity"
        ],
        "respuesta": 1
      }
    ]
  }
}